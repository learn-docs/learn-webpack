(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{572:function(e,t,a){"use strict";a.r(t);var s=a(9),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/learn-webpack/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),a("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),a("h2",{attrs:{id:"依赖图-dependency-graph"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖图-dependency-graph"}},[e._v("#")]),e._v(" 依赖图(dependency graph)")]),e._v(" "),a("p",[e._v("每当一个文件依赖另一个文件时，"),a("code",[e._v("webpack")]),e._v(" 都会将文件视为直接存在 依赖关系。这使得 "),a("code",[e._v("webpack")]),e._v(" 可以获取非代码资源，如 "),a("code",[e._v("images")]),e._v(" 或 "),a("code",[e._v("web")]),e._v(" 字体等。并会把它们作为 依赖 提供给应用程序。")]),e._v(" "),a("p",[e._v("当 "),a("code",[e._v("webpack")]),e._v(" 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 入口 开始，"),a("code",[e._v("webpack")]),e._v(" 会递归的构建一个 依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 "),a("code",[e._v("bundle")]),e._v(" —— 通常只有一个 —— 可由浏览器加载。")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[e._v("Tip\n对于 HTTP/1.1 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 HTTP/2 来说，你还可以使用代码分割进行进一步优化。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);