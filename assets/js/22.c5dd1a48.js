(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{580:function(a,e,r){"use strict";r.r(e);var l=r(9),o=Object(l.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("blockquote",[r("p",[a._v("点击勘误"),r("a",{attrs:{href:"https://github.com/webVueBlog/learn-webpack/issues",target:"_blank",rel:"noopener noreferrer"}},[a._v("issues"),r("OutboundLink")],1),a._v("，哪吒感谢大家的阅读")])]),a._v(" "),r("h2",{attrs:{id:"loader"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[a._v("#")]),a._v(" loader")]),a._v(" "),r("p",[a._v('loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 "load(加载)" 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS 文件！')]),a._v(" "),r("h2",{attrs:{id:"loader-特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader-特性"}},[a._v("#")]),a._v(" loader 特性")]),a._v(" "),r("ul",[r("li",[a._v("loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。")]),a._v(" "),r("li",[a._v("loader 可以是同步的，也可以是异步的。")]),a._v(" "),r("li",[a._v("loader 运行在 Node.js 中，并且能够执行任何操作。")]),a._v(" "),r("li",[a._v("loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。")]),a._v(" "),r("li",[a._v("除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。")]),a._v(" "),r("li",[a._v("插件(plugin)可以为 loader 带来更多特性。")]),a._v(" "),r("li",[a._v("loader 能够产生额外的任意文件。")])]),a._v(" "),r("p",[a._v("可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言转译（或编译）和 更多其他特性。")])])}),[],!1,null,null,null);e.default=o.exports}}]);