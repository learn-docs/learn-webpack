(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{584:function(s,a,e){"use strict";e.r(a);var t=e(9),r=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("blockquote",[e("p",[s._v("点击勘误"),e("a",{attrs:{href:"https://github.com/webVueBlog/learn-webpack/issues",target:"_blank",rel:"noopener noreferrer"}},[s._v("issues"),e("OutboundLink")],1),s._v("，哪吒感谢大家的阅读")])]),s._v(" "),e("h2",{attrs:{id:"模块解析-module-resolution"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块解析-module-resolution"}},[s._v("#")]),s._v(" 模块解析（Module Resolution）")]),s._v(" "),e("p",[s._v("resolver 是一个帮助寻找模块绝对路径的库。 一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：")]),s._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" foo "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'path/to/module'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 或者")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'path/to/module'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),e("p",[s._v("所依赖的模块可以是来自应用程序的代码或第三方库。 resolver 帮助 webpack 从每个 require/import 语句中，找到需要引入到 bundle 中的模块代码。 当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。")]),s._v(" "),e("h2",{attrs:{id:"webpack-中的解析规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-中的解析规则"}},[s._v("#")]),s._v(" webpack 中的解析规则")]),s._v(" "),e("p",[s._v("使用 enhanced-resolve，webpack 能解析三种文件路径：")]),s._v(" "),e("h3",{attrs:{id:"绝对路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绝对路径"}},[s._v("#")]),s._v(" 绝对路径")]),s._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'/home/me/file'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'C:\\\\Users\\\\me\\\\file'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),e("p",[s._v("由于已经获得文件的绝对路径，因此不需要再做进一步解析。")]),s._v(" "),e("h3",{attrs:{id:"相对路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相对路径"}},[s._v("#")]),s._v(" 相对路径")]),s._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'../src/file1'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'./file2'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),e("p",[s._v("在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录。在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。")]),s._v(" "),e("h3",{attrs:{id:"模块路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块路径"}},[s._v("#")]),s._v(" 模块路径")]),s._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'module'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'module/lib/file'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),e("p",[s._v("在 resolve.modules 中指定的所有目录中检索模块。 你可以通过配置别名的方式来替换初始模块路径，具体请参照 resolve.alias 配置选项。")]),s._v(" "),e("ul",[e("li",[s._v("如果 package 中包含 package.json 文件，那么在 resolve.exportsFields 配置选项中指定的字段会被依次查找，package.json 中的第一个字段会根据 package 导出指南确定 package 中可用的 export。")])]),s._v(" "),e("p",[s._v("一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件：")]),s._v(" "),e("ul",[e("li",[s._v("如果文件具有扩展名，则直接将文件打包。")]),s._v(" "),e("li",[s._v("否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 .js，.jsx）。")])]),s._v(" "),e("p",[s._v("如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：")]),s._v(" "),e("ul",[e("li",[s._v("如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。")]),s._v(" "),e("li",[s._v("如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。")]),s._v(" "),e("li",[s._v("然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。")])]),s._v(" "),e("p",[s._v("Webpack 会根据构建目标，为这些选项提供合理的默认配置。")]),s._v(" "),e("h2",{attrs:{id:"解析-loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析-loader"}},[s._v("#")]),s._v(" 解析 loader")]),s._v(" "),e("p",[s._v("loader 的解析规则也遵循特定的规范。但是 resolveLoader 配置项可以为 loader 设置独立的解析规则。")]),s._v(" "),e("h2",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[s._v("#")]),s._v(" 缓存")]),s._v(" "),e("p",[s._v("每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 watch 模式 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。")])])}),[],!1,null,null,null);a.default=r.exports}}]);