(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{589:function(e,_,v){"use strict";v.r(_);var t=v(9),n=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("blockquote",[v("p",[e._v("点击勘误"),v("a",{attrs:{href:"https://github.com/webVueBlog/learn-webpack/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),v("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),v("h2",{attrs:{id:"manifest"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#manifest"}},[e._v("#")]),e._v(" manifest")]),e._v(" "),v("p",[e._v("在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：")]),e._v(" "),v("ol",[v("li",[e._v("你或你的团队编写的源码。")]),e._v(" "),v("li",[e._v('你的源码会依赖的任何第三方的 library 或 "vendor" 代码。')]),e._v(" "),v("li",[e._v("webpack 的 runtime 和 manifest，管理所有模块的交互。")])]),e._v(" "),v("p",[e._v("本文将重点介绍这三个部分中的最后部分："),v("code",[e._v("runtime")]),e._v(" 和 "),v("code",[e._v("manifest")]),e._v("，特别是 "),v("code",[e._v("manifest")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"runtime"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[e._v("#")]),e._v(" runtime")]),e._v(" "),v("p",[v("code",[e._v("runtime")]),e._v("，以及伴随的 "),v("code",[e._v("manifest")]),e._v(" 数据，主要是指：在浏览器运行过程中，"),v("code",[e._v("webpack")]),e._v(" 用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。")]),e._v(" "),v("h2",{attrs:{id:"manifest-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#manifest-2"}},[e._v("#")]),e._v(" manifest")]),e._v(" "),v("p",[e._v("一旦你的应用在浏览器中以 "),v("code",[e._v("index.html")]),e._v(" 文件的形式被打开，一些 "),v("code",[e._v("bundle")]),e._v(" 和应用需要的各种资源都需要用某种方式被加载与链接起来。\n在经过打包、压缩、为延迟加载而拆分为细小的 "),v("code",[e._v("chunk")]),e._v(" 这些 "),v("code",[e._v("webpack")]),e._v(" 优化 之后，你精心安排的 "),v("code",[e._v("/src")]),e._v(" 目录的文件结构都已经不再存在。所以 "),v("code",[e._v("webpack")]),e._v(" 如何管理所有所需模块之间的交互呢？这就是 "),v("code",[e._v("manifest")]),e._v(" 数据用途的由来……")]),e._v(" "),v("p",[e._v("当 "),v("code",[e._v("compiler")]),e._v(' 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。\n这个数据集合称为 "'),v("code",[e._v("manifest")]),e._v('"，当完成打包并发送到浏览器时，'),v("code",[e._v("runtime")]),e._v(" 会通过 "),v("code",[e._v("manifest")]),e._v(" 来解析和加载模块。\n无论你选择哪种 模块语法，那些 "),v("code",[e._v("import")]),e._v(" 或 "),v("code",[e._v("require")]),e._v(" 语句现在都已经转换为 "),v("code",[e._v("__webpack_require__")]),e._v(" 方法，此方法指向模块标识符("),v("code",[e._v("module identifier")]),e._v(")。\n通过使用 "),v("code",[e._v("manifest")]),e._v(" 中的数据，"),v("code",[e._v("runtime")]),e._v(" 将能够检索这些标识符，找出每个标识符背后对应的模块。")]),e._v(" "),v("h2",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[e._v("#")]),e._v(" 问题")]),e._v(" "),v("p",[e._v("所以，现在你应该对 webpack 在幕后工作有一点了解。\n“但是，这对我有什么影响呢？”，你可能会问。答案是大多数情况下没有。\n"),v("code",[e._v("runtime")]),e._v(" 做完成这些工作：一旦你的应用程序加载到浏览器中，使用 "),v("code",[e._v("manifest")]),e._v("，然后所有内容将展现出魔幻般运行结果。\n然而，如果你决定通过使用浏览器缓存来改善项目的性能，理解这一过程将突然变得极为重要。")]),e._v(" "),v("p",[e._v("通过使用内容散列("),v("code",[e._v("content hash")]),e._v(")作为 "),v("code",[e._v("bundle")]),e._v(" 文件的名称，这样在文件内容修改时，会计算出新的 "),v("code",[e._v("hash")]),e._v("，浏览器会使用新的名称加载文件，从而使缓存无效。\n一旦你开始这样做，你会立即注意到一些有趣的行为。\n即使某些内容明显没有修改，某些 "),v("code",[e._v("hash")]),e._v(" 还是会改变。\n这是因为，注入的 "),v("code",[e._v("runtime")]),e._v(" 和 "),v("code",[e._v("manifest")]),e._v(" 在每次构建后都会发生变化。")])])}),[],!1,null,null,null);_.default=n.exports}}]);